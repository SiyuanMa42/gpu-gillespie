Metadata-Version: 2.4
Name: gpu-gillespie
Version: 1.0.1
Summary: High-performance GPU-accelerated Gillespie stochastic simulation algorithms
Home-page: https://github.com/SiyuanMa42/gpu-gillespie
Author: GPU-Gillespie Development Team
Author-email: GPU-Gillespie Development Team <contact@gpu-gillespie.org>
License: MIT
Project-URL: Homepage, https://github.com/SiyuanMa42/gpu-gillespie
Project-URL: Documentation, https://gpu-gillespie.readthedocs.io/
Project-URL: Repository, https://github.com/SiyuanMa42/gpu-gillespie.git
Project-URL: Bug Tracker, https://github.com/SiyuanMa42/gpu-gillespie/issues
Keywords: gillespie,stochastic simulation,gpu,cuda,parallel computing,biochemical networks
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Science/Research
Classifier: Topic :: Scientific/Engineering :: Bio-Informatics
Classifier: Topic :: Scientific/Engineering :: Chemistry
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Operating System :: OS Independent
Classifier: Environment :: GPU :: NVIDIA CUDA
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy>=1.19.0
Requires-Dist: scipy>=1.6.0
Requires-Dist: matplotlib>=3.3.0
Requires-Dist: pandas>=1.2.0
Requires-Dist: numba>=0.56.0
Requires-Dist: psutil>=5.8.0
Provides-Extra: dev
Requires-Dist: pytest>=6.0; extra == "dev"
Requires-Dist: pytest-cov>=2.0; extra == "dev"
Requires-Dist: black>=21.0; extra == "dev"
Requires-Dist: flake8>=3.8.0; extra == "dev"
Requires-Dist: mypy>=0.910; extra == "dev"
Requires-Dist: sphinx>=4.0; extra == "dev"
Requires-Dist: sphinx-rtd-theme>=1.0; extra == "dev"
Provides-Extra: docs
Requires-Dist: sphinx>=4.0; extra == "docs"
Requires-Dist: sphinx-rtd-theme>=1.0; extra == "docs"
Requires-Dist: nbsphinx>=0.8; extra == "docs"
Requires-Dist: myst-parser>=0.15; extra == "docs"
Provides-Extra: examples
Requires-Dist: jupyter>=1.0; extra == "examples"
Requires-Dist: seaborn>=0.11.0; extra == "examples"
Requires-Dist: plotly>=5.0.0; extra == "examples"
Requires-Dist: ipywidgets>=7.6; extra == "examples"
Dynamic: author
Dynamic: home-page
Dynamic: license-file
Dynamic: requires-python

# GPU-Gillespie: High-Performance Stochastic Simulation with GPU Acceleration

[![Python 3.7+](https://img.shields.io/badge/python-3.7+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![CUDA](https://img.shields.io/badge/CUDA-Enabled-green.svg)](https://developer.nvidia.com/cuda-toolkit)

A high-performance Python package for accelerating Gillespie stochastic simulation algorithms using GPU parallel computing. Built for computational biologists, systems biologists, and researchers working with stochastic chemical kinetics.

## üöÄ Key Features

- **GPU Acceleration**: Up to 100x speedup using NVIDIA CUDA and Numba
- **Parallel Execution**: Simulate thousands of trajectories simultaneously
- **Multiple Algorithms**: Exact Gillespie and tau-leaping approximation
- **Pre-built Models**: Ready-to-use biochemical reaction models
- **Advanced Analysis**: Comprehensive statistical analysis and visualization tools
- **Performance Monitoring**: Real-time GPU utilization and speedup metrics

## üìä Performance

| Configuration | CPU Time | GPU Time | Speedup |
|---------------|----------|----------|---------|
| 1,000 trajectories | 45.2s | 0.89s | **50.8x** |
| 10,000 trajectories | 452.1s | 4.2s | **107.6x** |
| 100,000 trajectories | 4,521s | 38.7s | **116.8x** |

*Benchmarks run on NVIDIA RTX 3080 with Intel i7-10700K*

## üõ†Ô∏è Installation

### Prerequisites

- Python 3.7 or higher
- NVIDIA GPU with CUDA support
- CUDA Toolkit 11.0 or higher

### Install from PyPI

```bash
pip install gpu-gillespie
```

### Install from Source

```bash
git clone https://github.com/gpu-gillespie/gpu-gillespie.git
cd gpu-gillespie
pip install -e .
```

### Development Installation

```bash
git clone https://github.com/gpu-gillespie/gpu-gillespie.git
cd gpu-gillespie
pip install -e ".[dev,examples]"
```

## üìñ Quick Start

### Basic Usage

```python
from gpu_gillespie import DimerizationModel

# Create a dimerization model
model = DimerizationModel(
    k_dimerization=0.1,
    k_dissociation=0.01,
    initial_A=1000,
    initial_A2=0
)

# Run GPU-accelerated simulation
results = model.run_simulation(
    time_span=(0, 100),
    n_timepoints=101,
    n_trajectories=10000
)

print(f"Simulation completed in {results['performance_stats']['execution_time']:.2f} seconds")
print(f"Achieved {results['performance_stats']['speedup_factor']:.1f}x speedup")
```

### Custom Model

```python
import numpy as np
from gpu_gillespie import GPUGillespieSimulator

# Define custom reaction network
species_names = ['A', 'B', 'C']
reaction_names = ['production', 'conversion', 'degradation']

# Stoichiometry matrix (negative for reactants, positive for products)
stoichiometry = np.array([
    [ 1,  0,  0],  # ‚àÖ ‚Üí A
    [-1,  1,  0],  # A ‚Üí B
    [ 0,  0, -1]   # C ‚Üí ‚àÖ
])

rate_constants = [1.0, 0.5, 0.1]

# Create simulator
simulator = GPUGillespieSimulator(
    species_names=species_names,
    reaction_names=reaction_names,
    stoichiometry=stoichiometry,
    rate_constants=rate_constants,
    initial_conditions={'A': 100, 'B': 0, 'C': 50}
)

# Run simulation
results = simulator.run_simulation(
    time_span=(0, 50),
    n_trajectories=5000
)

# Analyze results
analysis = simulator.analyze_results(results)
simulator.plot_trajectories(results)
```

### Advanced Parallel Simulations

```python
from gpu_gillespie import ParallelSimulator

# Create base simulator
simulator = GPUGillespieSimulator(...)

# Create parallel simulator
parallel_sim = ParallelSimulator(simulator)

# Parameter sweep
parameter_values = [0.01, 0.1, 1.0, 10.0]
sweep_results = parallel_sim.parameter_sweep(
    parameter_name='k_binding',
    parameter_values=parameter_values,
    n_trajectories_per_point=1000,
    n_workers=4
)

# Export results
import pandas as pd
df = parallel_sim.export_to_dataframe(sweep_results)
print(df.head())
```

## üìö Available Models

### Pre-built Models

- **DimerizationModel**: Simple monomer-dimer equilibrium
- **EnzymeKineticsModel**: Michaelis-Menten enzyme kinetics
- **GeneExpressionModel**: Transcription-translation system
- **ToggleSwitchModel**: Genetic toggle switch with mutual repression

### Model Gallery

```python
# Enzyme kinetics
enzyme_model = EnzymeKineticsModel(
    k_binding=1.0,
    k_dissociation=0.1,
    k_cat=0.5,
    initial_E=100,
    initial_S=1000
)

# Gene expression
gene_model = GeneExpressionModel(
    k_transcription=0.1,
    k_translation=0.2,
    k_mrna_degradation=0.05,
    k_protein_degradation=0.01
)
```

## üî¨ Advanced Features

### Performance Monitoring

```python
# Monitor GPU performance
results = simulator.run_simulation(...)
print(simulator.get_performance_summary(results))
```

### Statistical Analysis

```python
from gpu_gillespie import SimulationAnalyzer

analyzer = SimulationAnalyzer(results)
stats = analyzer.calculate_statistics()

# Generate comprehensive plots
fig = analyzer.plot_trajectory_overview()
fig2 = analyzer.plot_correlation_analysis()
```

### Tau-Leaping Approximation

```python
# Use faster tau-leaping for large systems
results = simulator.run_simulation(
    time_span=(0, 100),
    n_trajectories=10000,
    use_tau_leaping=True  # Enable approximation
)
```

## üìä Visualization

### Built-in Plotting

```python
# Plot trajectories
fig = simulator.plot_trajectories(
    results,
    species_subset=['A', 'B'],
    n_sample_trajectories=50,
    save_path='trajectories.png'
)

# Phase space analysis
analyzer.plot_phase_space('A', 'B', save_path='phase_space.png')
```

### Interactive Plotting with Plotly

```python
import plotly.graph_objects as go
import plotly.express as px

# Create interactive trajectory plot
fig = go.Figure()

for i, species in enumerate(results['species_names']):
    mean_traj = np.mean(results['species_trajectories'][:, :, i], axis=0)
    fig.add_trace(go.Scatter(
        x=results['time_points'],
        y=mean_traj,
        mode='lines',
        name=species
    ))

fig.update_layout(
    title='Species Trajectories',
    xaxis_title='Time',
    yaxis_title='Count',
    template='plotly_dark'
)

fig.show()
```

## üèóÔ∏è Architecture

### Core Components

- **GPUGillespieSimulator**: Main simulation interface
- **ParallelSimulator**: Advanced parallel simulation tools
- **CUDA Kernels**: Optimized GPU computation functions
- **PerformanceMonitor**: Real-time performance tracking
- **SimulationAnalyzer**: Statistical analysis tools

### GPU Acceleration

The package uses Numba CUDA to compile Python functions to GPU kernels:

```python
@cuda.jit
def gillespie_kernel(species_array, reactions_array, ...):
    # GPU-optimized Gillespie algorithm
    traj_idx = cuda.grid(1)  # Each thread handles one trajectory
    # ... parallel simulation logic
```

## üìà Benchmarks

### Performance Comparison

```python
from gpu_gillespie import BenchmarkSuite

# Run comprehensive benchmarks
benchmark = BenchmarkSuite()

# Test different trajectory counts
benchmark.run_benchmark(
    simulator=simulator,
    test_name='Dimerization Model',
    n_trajectories_list=[100, 1000, 10000],
    n_runs=3
)

# Generate report
print(benchmark.generate_report())
```

### System Requirements

- **Minimum**: NVIDIA GPU with 4GB VRAM, 1000 trajectories
- **Recommended**: NVIDIA RTX 3080+ with 10GB+ VRAM, 10000+ trajectories
- **Optimal**: NVIDIA A100 with 40GB+ VRAM, 100000+ trajectories

## üîß Troubleshooting

### Common Issues

1. **CUDA Out of Memory**: Reduce `n_trajectories` or use smaller models
2. **Slow Performance**: Ensure GPU drivers are up to date
3. **Import Errors**: Verify CUDA toolkit installation

### Performance Tips

- Use `tau_leaping=True` for faster approximate simulations
- Monitor GPU memory usage with `PerformanceMonitor`
- Batch large parameter sweeps to avoid memory issues

## üìö Examples

### Complete Example: Enzyme Kinetics

```python
import numpy as np
from gpu_gillespie import EnzymeKineticsModel
import matplotlib.pyplot as plt

# Create enzyme model
model = EnzymeKineticsModel(
    k_binding=1.0,
    k_dissociation=0.1,
    k_cat=0.5,
    initial_E=100,
    initial_S=1000,
    initial_ES=0,
    initial_P=0
)

# Run simulation
results = model.run_simulation(
    time_span=(0, 200),
    n_timepoints=201,
    n_trajectories=5000
)

# Analyze results
analyzer = model.simulator.analyze_results(results)

# Print key metrics
print(f"Michaelis constant (Km): {model.get_michaelis_constant():.3f}")
print(f"Maximum velocity (Vmax): {model.get_max_velocity(100):.1f}")

# Create visualization
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Plot trajectories
model.simulator.plot_trajectories(results, axes=axes[0, 0])

# Plot final distributions
final_states = results['species_trajectories'][:, -1, :]
for i, species in enumerate(results['species_names']):
    axes[0, 1].hist(final_states[:, i], bins=30, alpha=0.7, label=species)
axes[0, 1].set_xlabel('Final Count')
axes[0, 1].set_ylabel('Frequency')
axes[0, 1].set_title('Final State Distributions')
axes[0, 1].legend()

# Plot time series of means
for i, species in enumerate(results['species_names']):
    mean_traj = np.mean(results['species_trajectories'][:, :, i], axis=0)
    axes[1, 0].plot(results['time_points'], mean_traj, label=species)
axes[1, 0].set_xlabel('Time')
axes[1, 0].set_ylabel('Mean Count')
axes[1, 0].set_title('Mean Trajectories')
axes[1, 0].legend()

# Performance metrics
performance = results['performance_stats']
axes[1, 1].bar(['Execution Time', 'Speedup'], 
               [performance['execution_time'], performance['speedup_factor']])
axes[1, 1].set_ylabel('Value')
axes[1, 1].set_title('Performance Metrics')

plt.tight_layout()
plt.show()
```

## ü§ù Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

### Development Setup

```bash
git clone https://github.com/gpu-gillespie/gpu-gillespie.git
cd gpu-gillespie
pip install -e ".[dev]"
pre-commit install
```

### Running Tests

```bash
pytest tests/ -v --cov=gpu_gillespie
```

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- **Gillespy2**: For the original stochastic simulation algorithms
- **Numba**: For CUDA Python compilation
- **NumPy**: For efficient numerical computing
- **SciPy**: For statistical analysis tools

## üìÆ Contact

- **Email**: contact@gpu-gillespie.org
- **Issues**: [GitHub Issues](https://github.com/gpu-gillespie/gpu-gillespie/issues)
- **Discussions**: [GitHub Discussions](https://github.com/gpu-gillespie/gpu-gillespie/discussions)

## üåü Citation

If you use GPU-Gillespie in your research, please cite:

```bibtex
@software{gpu_gillespie,
  title={GPU-Gillespie: High-Performance Stochastic Simulation with GPU Acceleration},
  author={GPU-Gillespie Development Team},
  year={2024},
  url={https://github.com/gpu-gillespie/gpu-gillespie},
  version={1.0.0}
}
```

---

**GPU-Gillespie** - Accelerating scientific discovery through parallel computing üöÄ
